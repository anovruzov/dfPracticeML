#!/usr/bin/env python3
import json
from typing import Any, Dict, List, Tuple


class JSONComparator:

    def __init__(self, config_path: str, operational_path: str):
        self.config_path = config_path
        self.operational_path = operational_path

    def load_json(self, path: str) -> Any:
        """Load JSON from a file or exit with an error if missing/invalid."""
        try:
            with open(path, "r") as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"ERROR: File '{path}' not found.")
        except json.JSONDecodeError as e:
            print(f"ERROR: Invalid JSON in '{path}': {e}")

    def repr_value(self, val: Any) -> str:
        if val is None:
            return "null"
        if isinstance(val, str):
            return '""' if val == "" else f'"{val}"'
        if isinstance(val, bool):
            return "true" if val else "false"
        if isinstance(val, (int, float)):
            return str(val)
        if isinstance(val, list):
            return f"[list,len={len(val)}]"
        if isinstance(val, dict):
            return "{dict}"
        return str(val)

    def compare_subtree(
        self,
        cfg: Any,
        op: Any,
        path: List[str],
        rows: List[Tuple[str, str, str, str]],
    ) -> None:
        # CASE 1: Both are dicts → union keys, recurse
        if isinstance(cfg, dict) and isinstance(op, dict):
            all_keys = sorted(set(cfg.keys()) | set(op.keys()))
            for key in all_keys:
                new_path = path + [str(key)]
                key_path = "/".join(new_path)

                in_cfg = key in cfg
                in_op = key in op

                if in_cfg and not in_op:
                    rows.append((key_path, self.repr_value(cfg[key]), "<missing>", "MISSING in operational"))
                elif in_op and not in_cfg:
                    rows.append((key_path, "<missing>", self.repr_value(op[key]), "MISSING in config"))
                else:
                    val_cfg = cfg[key]
                    val_op = op[key]
                    # Check null/empty on either side
                    if val_cfg is None or (isinstance(val_cfg, str) and val_cfg == ""):
                        rows.append((key_path, "<null or empty>", self.repr_value(val_op), "VALUE MISSING in config"))
                    elif val_op is None or (isinstance(val_op, str) and val_op == ""):
                        rows.append((key_path, self.repr_value(val_cfg), "<null or empty>", "VALUE MISSING in operational"))
                    else:
                        self.compare_subtree(val_cfg, val_op, new_path, rows)
            return

        # CASE 2: Both are lists → compare index by index
        if isinstance(cfg, list) and isinstance(op, list):
            max_len = max(len(cfg), len(op))
            for idx in range(max_len):
                new_path = path + [f"[{idx}]"]
                idx_path = "/".join(new_path)
                if idx >= len(cfg):
                    rows.append((idx_path, "<missing>", self.repr_value(op[idx]), "MISSING in config"))
                elif idx >= len(op):
                    rows.append((idx_path, self.repr_value(cfg[idx]), "<missing>", "MISSING in operational"))
                else:
                    self.compare_subtree(cfg[idx], op[idx], new_path, rows)
            return

        # CASE 3: Types differ
        if type(cfg) != type(op):
            rows.append(("/".join(path), self.repr_value(cfg), self.repr_value(op), "TYPE MISMATCH"))
            return

        # CASE 4: Primitives (or same-type) → direct value compare
        if cfg != op:
            rows.append(("/".join(path), self.repr_value(cfg), self.repr_value(op), "VALUE MISMATCH"))
        else:
            rows.append(("/".join(path), self.repr_value(cfg), self.repr_value(op), "MATCH"))

    def print_device_comparison(
        self,
        device_id: str,
        cfg_dev: Any,
        op_dev: Any,
    ) -> None:
        # Build a banner string like "=== DEVICE: DEV1 ===" in uppercase
        title = f" DEVICE: {device_id.upper()} "
        banner = "=" * len(title)

        # Print the banner
        print("\n" + banner)
        print(title)
        print(banner)

        # If both sides are missing entirely, nothing to show
        if cfg_dev is None and op_dev is None:
            print(f"\n⚠️  Device '{device_id}' missing in both CONFIG and OPERATIONAL.\n")
            return

        # If missing in config, treat cfg_dev as an empty dict
        if cfg_dev is None:
            print(f"\n⚠️  Device '{device_id}' is missing in CONFIG. Showing OPERATIONAL data only.\n")
            cfg_dev = {}

        # If missing in operational, treat op_dev as an empty dict
        if op_dev is None:
            print(f"\n⚠️  Device '{device_id}' is missing in OPERATIONAL. Showing CONFIG data only.\n")
            op_dev = {}

        # Recursively compare the two subtrees (one side might be {} if originally missing)
        rows: List[Tuple[str, str, str, str]] = []
        self.compare_subtree(cfg_dev, op_dev, path=[], rows=rows)

        # Compute column widths
        path_w = max(len("FIELD"), *(len(r[0]) for r in rows))
        cfg_w = max(len("CONFIG"), *(len(r[1]) for r in rows))
        op_w = max(len("OPERATIONAL"), *(len(r[2]) for r in rows))
        stat_w = max(len("STATUS"), *(len(r[3]) for r in rows))

        # Print header
        header = (
            f"{'FIELD'.ljust(path_w)}  "
            f"{'CONFIG'.ljust(cfg_w)}  "
            f"{'OPERATIONAL'.ljust(op_w)}  "
            f"{'STATUS'.ljust(stat_w)}"
        )
        divider = "-" * len(header)
        print(header)
        print(divider)

        # Print each row
        for field_path, cfg_val, op_val, status in rows:
            line = (
                f"{field_path.ljust(path_w)}  "
                f"{cfg_val.ljust(cfg_w)}  "
                f"{op_val.ljust(op_w)}  "
                f"{status.ljust(stat_w)}"
            )
            print(line)

        if not rows:
            print("(No differences found — everything matches.)")

    def run(self) -> None:
        """
        Entry point: Load both JSONs, build device lookup, and print per-device comparisons.
        """
        # 1) Load both JSON files
        config_data = self.load_json(self.config_path)
        op_data = self.load_json(self.operational_path)

        # 2) Build lookup dicts for each "openroadm-device" by device-id
        cfg_devices: Dict[str, Any] = {}
        op_devices: Dict[str, Any] = {}

        cfg_list = config_data.get("openroadm-devices", {}).get("openroadm-device", [])
        op_list = op_data.get("openroadm-devices", {}).get("openroadm-device", [])

        for entry in cfg_list:
            dev_id = entry.get("device-id")
            if isinstance(dev_id, str):
                cfg_devices[dev_id] = entry

        for entry in op_list:
            dev_id = entry.get("device-id")
            if isinstance(dev_id, str):
                op_devices[dev_id] = entry

        # 3) Collect all unique device IDs (from both sides)
        all_ids = sorted(set(cfg_devices.keys()) | set(op_devices.keys()))

        if not all_ids:
            print("⚠️  No 'openroadm-device' entries found in either JSON.")
            return

        # 4) For each device-id, print its comparison section
        for dev_id in all_ids:
            cfg_dev = cfg_devices.get(dev_id)  # None if missing in config
            op_dev = op_devices.get(dev_id)    # None if missing in operational
            self.print_device_comparison(dev_id, cfg_dev, op_dev)


if __name__ == "__main__":
    comparator = JSONComparator("config.json", "op.json")
    comparator.run()
